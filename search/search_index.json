{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p><code>ko</code> makes building Go container images easy, fast, and secure by default.</p> <p></p> <p><code>ko</code> is a simple, fast container image builder for Go applications.</p> <p>It's ideal for use cases where your image contains a single Go application without many dependencies on the OS base image (e.g., no cgo, no OS package dependencies).</p> <p><code>ko</code> builds images by executing <code>go build</code> on your local machine, and as such doesn't require <code>docker</code> to be installed. This can make it a good fit for lightweight CI/CD use cases.</p> <p><code>ko</code> makes multi-platform builds easy, produces SBOMs by default, and includes support for simple YAML templating which makes it a powerful tool for Kubernetes applications.</p> <p>\ud83c\udfc3 Install <code>ko</code> and get started!</p> <p><code>ko</code> is used and loved by these open source projects:</p> <ul> <li>Knative</li> <li>Tekton</li> <li>Karpenter</li> <li>Kyverno</li> <li>Sigstore</li> <li>Shipwright</li> <li>Capsule</li> <li>CloudScript</li> <li>Kamaji</li> </ul> <p>Add your project here!</p> <p><code>ko</code> is a Cloud Native Computing Foundation Sandbox project.</p> <p> </p>"},{"location":"community/","title":"Community","text":""},{"location":"community/#meetings","title":"Meetings","text":"<p>We have a bi-weekly community meeting on Wednesdays at 1:00 PM US Eastern time, 10:00 AM US Western time. The main goal of these meetings is that we want to hear from you! We want to know what you're using <code>ko</code> for, what you'd like to see in <code>ko</code>, how we can make <code>ko</code> better for you. With any remaining time we can go through open issues and PRs.</p> <p>We have a meeting agenda you can use to propose topics for discussion/ideas. You can also just show up and we'll figure out what to talk about.</p>"},{"location":"community/#slack","title":"Slack","text":"<p>Come discuss <code>ko</code> with us in the <code>#ko-build</code> channel on the Kubernetes Slack! See you there!</p>"},{"location":"configuration/","title":"Configuration","text":""},{"location":"configuration/#basic-configuration","title":"Basic Configuration","text":"<p>Aside from certain environment variables (see below) like <code>KO_DOCKER_REPO</code>, you can configure <code>ko</code>'s behavior using a <code>.ko.yaml</code> file. The location of this file can be overridden with <code>KO_CONFIG_PATH</code>.</p>"},{"location":"configuration/#overriding-base-images","title":"Overriding Base Images","text":"<p>By default, <code>ko</code> bases images on <code>cgr.dev/chainguard/static</code>. This is a small image that provides the bare necessities to run your Go binary.</p> <p>You can override this base image in two ways:</p> <ol> <li>To override the base image for all images <code>ko</code> builds, add this line to your    <code>.ko.yaml</code> file:</li> </ol> <pre><code>defaultBaseImage: registry.example.com/base/image\n</code></pre> <p>You can also use the <code>KO_DEFAULTBASEIMAGE</code> environment variable to set the default base image, which overrides the YAML configuration:</p> <pre><code>KO_DEFAULTBASEIMAGE=registry.example.com/base/image ko build .\n</code></pre> <ol> <li>To override the base image for certain importpaths:</li> </ol> <pre><code>baseImageOverrides:\n  github.com/my-user/my-repo/cmd/app: registry.example.com/base/for/app\n  github.com/my-user/my-repo/cmd/foo: registry.example.com/base/for/foo\n</code></pre>"},{"location":"configuration/#overriding-go-build-settings","title":"Overriding Go build settings","text":"<p>By default, <code>ko</code> builds the binary with no additional build flags other than <code>-trimpath</code>. You can replace the default build arguments by providing build flags and ldflags using a GoReleaser influenced <code>builds</code> configuration section in your <code>.ko.yaml</code>.</p> <pre><code>builds:\n- id: foo\n  dir: .  # default is .\n  main: ./foobar/foo\n  env:\n  - GOPRIVATE=git.internal.example.com,source.developers.google.com\n  flags:\n  - -tags\n  - netgo\n  ldflags:\n  - -s -w\n  - -extldflags \"-static\"\n  - -X main.version={{.Env.VERSION}}\n- id: bar\n  dir: ./bar\n  main: .  # default is .\n  env:\n  - GOCACHE=/workspace/.gocache\n  ldflags:\n  - -s\n  - -w\n</code></pre> <p>If your repository contains multiple modules (multiple <code>go.mod</code> files in different directories), use the <code>dir</code> field to specify the directory where <code>ko</code> should run <code>go build</code>.</p> <p><code>ko</code> picks the entry from <code>builds</code> based on the import path you request. The import path is matched against the result of joining <code>dir</code> and <code>main</code>.</p> <p>The paths specified in <code>dir</code> and <code>main</code> are relative to the working directory of the <code>ko</code> process.</p> <p>The <code>ldflags</code> default value is <code>[]</code>.</p>"},{"location":"configuration/#templating-support","title":"Templating support","text":"<p>The <code>ko</code> builds supports templating of <code>flags</code> and <code>ldflags</code>, similar to the GoReleaser <code>builds</code> section.</p> <p>The table below lists the supported template parameters.</p> Template param Description <code>Env</code> Map of environment variables used for the build <code>GoEnv</code> Map of <code>go env</code> environment variables used for the build <code>Date</code> The UTC build date in RFC 3339 format <code>Timestamp</code> The UTC build date as Unix epoc seconds <code>Git.Branch</code> The current git branch <code>Git.Tag</code> The current git tag <code>Git.ShortCommit</code> The git commit short hash <code>Git.FullCommit</code> The git commit full hash <code>Git.CommitDate</code> The UTC commit date in RFC 3339 format <code>Git.CommitTimestamp</code> The UTC commit date in Unix format <code>Git.IsDirty</code> Whether or not current git state is dirty <code>Git.IsClean</code> Whether or not current git state is clean. <code>Git.TreeState</code> Either <code>clean</code> or <code>dirty</code>"},{"location":"configuration/#setting-default-platforms","title":"Setting default platforms","text":"<p>By default, <code>ko</code> builds images based on the platform it runs on. If your target platform differs from your build platform you can specify the build platform:</p> <p>As a parameter See Multi-Platform Images.</p> <p>In .ko.yaml Add this to your <code>.ko.yaml</code> file:</p> <pre><code>defaultPlatforms:\n- linux/arm64\n- linux/amd64\n</code></pre> <p>You can also use the <code>KO_DEFAULTPLATFORMS</code> environment variable to set the default platforms, which overrides the YAML configuration:</p> <pre><code>KO_DEFAULTPLATFORMS=linux/arm64,linux/amd64\n</code></pre>"},{"location":"configuration/#setting-build-environment-variables","title":"Setting build environment variables","text":"<p>By default, <code>ko</code> builds use the ambient environment from the system (i.e. <code>os.Environ()</code>). These values can be overridden for your build.</p> <pre><code>defaultEnv:\n- FOO=foo\nbuilds:\n- id: foo\n  dir: .\n  main: ./foobar/foo\n  env:\n  - FOO=bar\n- id: bar     # Will use defaultEnv.\n  dir: ./bar\n  main: .\n</code></pre> <p>For a given build, the environment variables are merged in the following order:</p> <ul> <li>System <code>os.Environ</code> (lowest precedence)</li> <li>Build variables: <code>build.env</code> if specified, otherwise <code>defaultEnv</code> (highest precedence)</li> </ul>"},{"location":"configuration/#setting-build-flags-and-ldflags","title":"Setting build flags and ldflags","text":"<p>You can specify both <code>flags</code> and <code>ldflags</code> globally as well as per-build.</p> <pre><code>defaultFlags:\n- -v\ndefaultLdflags:\n- -s\nbuilds:\n- id: foo\n  dir: .\n  main: ./foobar/foo\n  flags:\n  - -trimpath\n  ldflags:\n  - -w\n- id: bar     # Will use defaultFlags and defaultLdflags.\n  dir: ./bar\n  main: .\n</code></pre> <p>The values for a <code>build</code> will be used if specified, otherwise their respective defaults will be used. Both default and per-build values may use template parameters.</p>"},{"location":"configuration/#environment-variables-advanced","title":"Environment Variables (advanced)","text":"<p>For ease of use, backward compatibility and advanced use cases, <code>ko</code> supports the following environment variables to influence the build process.</p> Variable Default Value Description <code>KO_DOCKER_REPO</code> (not set) Container repository where to push images built with <code>ko</code> (required) <code>KO_GO_PATH</code> <code>go</code> <code>go</code> binary to use for builds, relative or absolute path, otherwise looked up via $PATH (optional) <code>KO_CONFIG_PATH</code> <code>./.ko.yaml</code> Path to <code>ko</code> configuration file (optional) <code>KOCACHE</code> (not set) This tells <code>ko</code> to store a local mapping between the <code>go build</code> inputs to the image layer that they produce, so <code>go build</code> can be skipped entirely if the layer is already present in the image registry (optional)."},{"location":"configuration/#naming-images","title":"Naming Images","text":"<p><code>ko</code> provides a few different strategies for naming the image it pushes, to workaround certain registry limitations and user preferences:</p> <p>Given <code>KO_DOCKER_REPO=registry.example.com/repo</code>, by default, <code>ko build ./cmd/app</code> will produce an image named like <code>registry.example.com/repo/app-&lt;md5&gt;</code>, which includes the MD5 hash of the full import path, to avoid collisions.</p> <ul> <li><code>--preserve-import-paths</code> (<code>-P</code>) will include the entire importpath:   <code>registry.example.com/repo/github.com/my-user/my-repo/cmd/app</code></li> <li><code>--base-import-paths</code> (<code>-B</code>) will omit the MD5 portion:   <code>registry.example.com/repo/app</code></li> <li><code>--bare</code> will only include the <code>KO_DOCKER_REPO</code>: <code>registry.example.com/repo</code></li> </ul>"},{"location":"configuration/#local-publishing-options","title":"Local Publishing Options","text":"<p><code>ko</code> is normally used to publish images to container image registries, identified by <code>KO_DOCKER_REPO</code>.</p> <p><code>ko</code> can also load images to a local Docker daemon, if available, by setting <code>KO_DOCKER_REPO=ko.local</code>, or by passing the <code>--local</code> (<code>-L</code>) flag.</p> <p>Local images can be used as a base image for other <code>ko</code> images:</p> <pre><code>defaultBaseImage: ko.local/example/base/image\n</code></pre> <p><code>ko</code> can also load images into a local KinD cluster, if available, by setting <code>KO_DOCKER_REPO=kind.local</code>. By default this loads into the default KinD cluster name (<code>kind</code>). To load into another KinD cluster, set <code>KIND_CLUSTER_NAME=my-other-cluster</code>.</p>"},{"location":"deployment/","title":"Deployment","text":"<p>See Kubernetes Integration for information about deploying to Kubernetes.</p> <p>Because the output of <code>ko build</code> is an image reference, you can easily pass it to other tools that expect to take an image reference.</p>"},{"location":"deployment/#docker-run","title":"<code>docker run</code>","text":"<p>To run the container locally:</p> <pre><code>docker run -p 8080:8080 $(ko build ./cmd/app)\n</code></pre>"},{"location":"deployment/#google-cloud-run","title":"Google Cloud Run","text":"<pre><code>gcloud run deploy --image=$(ko build ./cmd/app)\n</code></pre> <p>\ud83d\udca1 Note: The image must be pushed to Google Container Registry or Artifact Registry.</p>"},{"location":"deployment/#flyio","title":"fly.io","text":"<pre><code>flyctl launch --image=$(ko build ./cmd/app)\n</code></pre> <p>\ud83d\udca1 Note: The image must be pushed to Fly.io's container registry at <code>registry.fly.io</code>, or if not, the image must be publicly available. When pushing to <code>registry.fly.io</code>, you must first log in with <code>flyctl auth docker</code>.</p>"},{"location":"deployment/#aws-lambda","title":"AWS Lambda","text":"<pre><code>aws lambda update-function-code \\\n  --function-name=my-function-name \\\n  --image-uri=$(ko build ./cmd/app)\n</code></pre> <p>\ud83d\udca1 Note: The image must be pushed to ECR, based on the AWS provided base image, and use the <code>aws-lambda-go</code> framework. See official docs for more information.</p>"},{"location":"deployment/#azure-container-apps","title":"Azure Container Apps","text":"<pre><code>az containerapp update \\\n  --name my-container-app\n  --resource-group my-resource-group\n  --image $(ko build ./cmd/app)\n</code></pre> <p>\ud83d\udca1 Note: The image must be pushed to ACR or other registry service. See official docs for more information.</p>"},{"location":"get-started/","title":"Get Started","text":""},{"location":"get-started/#setup","title":"Setup","text":"<p>First, install <code>ko</code>.</p>"},{"location":"get-started/#authenticate","title":"Authenticate","text":"<p><code>ko</code> depends on the authentication configured in your Docker config (typically <code>~/.docker/config.json</code>).</p> <p>\u2728 If you can push an image with <code>docker push</code>, you are already authenticated for <code>ko</code>! \u2728</p> <p>Since <code>ko</code> doesn't require <code>docker</code>, <code>ko login</code> also provides a surface for logging in to a container image registry with a username and password, similar to <code>docker login</code>.</p> <p>Additionally, even if auth is not configured in the Docker config, <code>ko</code> includes built-in support for authenticating to the following container registries using credentials configured in the environment:</p> <ul> <li>Google Container Registry and Artifact Registry, using Application Default Credentials or auth configured in <code>gcloud</code>.</li> <li>Amazon Elastic Container Registry, using AWS credentials</li> <li>Azure Container Registry, using environment variables</li> <li>GitHub Container Registry, using the <code>GITHUB_TOKEN</code> environment variable</li> </ul>"},{"location":"get-started/#choose-destination","title":"Choose Destination","text":"<p><code>ko</code> depends on an environment variable, <code>KO_DOCKER_REPO</code>, to identify where it should push images that it builds. Typically this will be a remote registry, e.g.:</p> <ul> <li><code>KO_DOCKER_REPO=gcr.io/my-project</code>, or</li> <li><code>KO_DOCKER_REPO=ghcr.io/my-org/my-repo</code>, or</li> <li><code>KO_DOCKER_REPO=my-dockerhub-user</code></li> </ul>"},{"location":"get-started/#build-an-image","title":"Build an Image","text":"<p><code>ko build ./cmd/app</code> builds and pushes a container image, and prints the resulting image digest to stdout.</p> <p>In this example, <code>./cmd/app</code> must be a <code>package main</code> that defines <code>func main()</code>.</p> <pre><code>$ ko build ./cmd/app\n...\nregistry.example.com/my-project/app-099ba5bcefdead87f92606265fb99ac0@sha256:6e398316742b7aa4a93161dce4a23bc5c545700b862b43347b941000b112ec3e\n</code></pre> <p>\ud83d\udca1 Note: Prior to v0.10, the command was called <code>ko publish</code> -- this is equivalent to <code>ko build</code>, and both commands will work and do the same thing.</p> <p>The executable binary that was built from <code>./cmd/app</code> is available in the image at <code>/ko-app/app</code> -- the binary name matches the base import path name -- and that binary is the image's entrypoint.</p>"},{"location":"install/","title":"Installation","text":""},{"location":"install/#install-from-github-releases","title":"Install from GitHub Releases","text":"<pre><code>$ VERSION=TODO # choose the latest version (without v prefix)\n$ OS=Linux     # or Darwin\n$ ARCH=x86_64  # or arm64, i386, s390x\n</code></pre> <p>We generate SLSA3 provenance using the OpenSSF's slsa-framework/slsa-github-generator. To verify our release, install the verification tool from slsa-framework/slsa-verifier#installation and verify as follows:</p> <pre><code>$ curl -sSfL \"https://github.com/ko-build/ko/releases/download/v${VERSION}/ko_${VERSION}_${OS}_${ARCH}.tar.gz\" &gt; ko.tar.gz\n$ curl -sSfL https://github.com/ko-build/ko/releases/download/v${VERSION}/multiple.intoto.jsonl &gt; multiple.intoto.jsonl\n$ slsa-verifier verify-artifact --provenance-path multiple.intoto.jsonl --source-uri github.com/ko-build/ko --source-tag \"v${VERSION}\" ko.tar.gz\nVerified signature against tlog entry index 24413745 at URL: https://rekor.sigstore.dev/api/v1/log/entries/24296fb24b8ad77ab97a5263b5fa8f35789618348a39358b1f9470b0c31045effbbe5e23e77a5836\nVerified build using builder \"https://github.com/slsa-framework/slsa-github-generator/.github/workflows/generator_generic_slsa3.yml@refs/tags/v1.7.0\" at commit 200db7243f02b5c0303e21d8ab8e3b4ad3a229d0\nVerifying artifact /Users/batuhanapaydin/workspace/ko/ko.tar.gz: PASSED\n\nPASSED: Verified SLSA provenance\n</code></pre> <pre><code>$ tar xzf ko.tar.gz ko\n$ chmod +x ./ko\n</code></pre>"},{"location":"install/#install-using-homebrew","title":"Install using Homebrew","text":"<pre><code>brew install ko\n</code></pre>"},{"location":"install/#install-using-macports","title":"Install using MacPorts","text":"<pre><code>sudo port install ko\n</code></pre> <p>More info here</p>"},{"location":"install/#install-on-windows-using-scoop","title":"Install on Windows using Scoop","text":"<pre><code>scoop install ko\n</code></pre>"},{"location":"install/#install-on-alpine-linux","title":"Install on Alpine Linux","text":"<p>Installation on Alpine requires using the <code>testing</code> repository</p> <pre><code>echo https://dl-cdn.alpinelinux.org/alpine/edge/testing/ &gt;&gt; /etc/apk/repositories\napk update\napk add ko\n</code></pre>"},{"location":"install/#build-and-install-from-source","title":"Build and Install from source","text":"<p>With Go 1.16+, build and install the latest released version:</p> <pre><code>go install github.com/google/ko@latest\n</code></pre>"},{"location":"install/#setup-on-github-actions","title":"Setup on GitHub Actions","text":"<p>You can use the setup-ko action to install ko and setup auth to GitHub Container Registry in a GitHub Action workflow:</p> <pre><code>steps:\n- uses: ko-build/setup-ko@v0.6\n</code></pre>"},{"location":"advanced/faq/","title":"Frequently Asked Questions","text":""},{"location":"advanced/faq/#how-can-i-set-ldflags","title":"How can I set <code>ldflags</code>?","text":"<p>Using -ldflags is a common way to embed version info in go binaries (In fact, we do this for <code>ko</code>!). Unfortunately, because <code>ko</code> wraps <code>go build</code>, it's not possible to use this flag directly; however, you can use the <code>GOFLAGS</code> environment variable instead:</p> <pre><code>GOFLAGS=\"-ldflags=-X=main.version=1.2.3\" ko build .\n</code></pre> <p>Currently, there is a limitation that does not allow to set multiple arguments in <code>ldflags</code> using <code>GOFLAGS</code>. Using <code>-ldflags</code> multiple times also does not work. In this use case, it works best to use the <code>builds</code> section in the <code>.ko.yaml</code> file.</p>"},{"location":"advanced/faq/#why-are-my-images-all-created-in-1970","title":"Why are my images all created in 1970?","text":"<p>In order to support reproducible builds, <code>ko</code> doesn't embed timestamps in the images it produces by default.</p> <p>However, <code>ko</code> does respect the <code>SOURCE_DATE_EPOCH</code> environment variable, which will set the container image's timestamp accordingly.</p> <p>Similarly, the <code>KO_DATA_DATE_EPOCH</code> environment variable can be used to set the modtime timestamp of the files in <code>KO_DATA_PATH</code>.</p> <p>For example, you can set the container image's timestamp to the current timestamp by executing:</p> <pre><code>export SOURCE_DATE_EPOCH=$(date +%s)\n</code></pre> <p>or set the timestamp of the files in <code>KO_DATA_PATH</code> to the latest git commit's timestamp with:</p> <pre><code>export KO_DATA_DATE_EPOCH=$(git log -1 --format='%ct')\n</code></pre>"},{"location":"advanced/faq/#can-i-build-windows-containers","title":"Can I build Windows containers?","text":"<p>Yes, but support for Windows containers is new, experimental, and tenuous. Be prepared to file bugs. \ud83d\udc1b</p> <p>The default base image does not provide a Windows image. You can try out building a Windows container image by setting the base image to a Windows base image and building with <code>--platform=windows/amd64</code> or <code>--platform=all</code>:</p> <p>For example, to build a Windows container image, update your <code>.ko.yaml</code> to set the base image:</p> <pre><code>defaultBaseImage: mcr.microsoft.com/windows/nanoserver:ltsc2022\n</code></pre> <p>And build for <code>windows/amd64</code>.</p> <pre><code>ko build ./ --platform=windows/amd64\n</code></pre>"},{"location":"advanced/faq/#known-issues","title":"Known issues \ud83d\udc1b","text":"<ul> <li>Symlinks in <code>kodata</code> are ignored when building Windows images; only regular files and directories will be included in the Windows image.</li> </ul>"},{"location":"advanced/faq/#does-ko-support-autocompletion","title":"Does <code>ko</code> support autocompletion?","text":"<p>Yes! <code>ko completion</code> generates a Bash/Zsh/Fish/PowerShell completion script. You can get how to load it from help document.</p> <pre><code>ko completion [bash|zsh|fish|powershell] --help\n</code></pre> <p>Or, you can source it directly:</p> <pre><code>source &lt;(ko completion)\n</code></pre>"},{"location":"advanced/faq/#does-ko-work-with-kustomize","title":"Does <code>ko</code> work with Kustomize?","text":"<p>Yes! <code>ko resolve -f -</code> will read and process input from stdin, so you can have <code>ko</code> easily process the output of the <code>kustomize</code> command.</p> <pre><code>kustomize build config | ko resolve -f -\n</code></pre>"},{"location":"advanced/faq/#does-ko-integrate-with-other-build-and-development-tools","title":"Does <code>ko</code> integrate with other build and development tools?","text":"<p>Oh, you betcha. Here's a partial list:</p> <ul> <li><code>ko</code> support in Skaffold</li> <li><code>ko</code> support for goreleaser</li> <li><code>ko</code> task in the Tekton catalog</li> <li><code>ko</code> support in Carvel's <code>kbld</code></li> <li><code>ko</code> extension for Tilt</li> </ul>"},{"location":"advanced/faq/#does-ko-work-with-openshift-internal-registry","title":"Does <code>ko</code> work with OpenShift Internal Registry?","text":"<p>Yes! Follow these steps:</p> <ol> <li>Connect to your OpenShift installation</li> <li>Expose the OpenShift Internal\u00a0Registry so you can push to it:</li> <li>Export your token to <code>$HOME/.docker/config.json</code>:</li> </ol> <pre><code>oc registry login --to=$HOME/.docker/config.json\n</code></pre> <ol> <li>Create a namespace where you will push your images, i.e: <code>ko-images</code></li> <li>Execute this command to set <code>KO_DOCKER_REPO</code> to publish images to the internal registry.</li> </ol> <pre><code>export KO_DOCKER_REPO=$(oc registry info --public)/ko-images\n</code></pre>"},{"location":"advanced/go-packages/","title":"Go Packages","text":"<p><code>ko</code>'s functionality can be consumed as a library in a Go application.</p> <p>To build an image, use <code>pkg/build</code>, and publish it with <code>pkg/publish</code>.</p> <p>This is a minimal example of using the packages together, to implement the core subset of <code>ko</code>'s functionality:</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n\n    \"github.com/google/go-containerregistry/pkg/authn\"\n    \"github.com/google/go-containerregistry/pkg/name\"\n    \"github.com/google/go-containerregistry/pkg/v1/remote\"\n    \"github.com/google/ko/pkg/build\"\n    \"github.com/google/ko/pkg/publish\"\n)\n\nconst (\n    baseImage  = \"cgr.dev/chainguard/static:latest\"\n    targetRepo = \"example.registry/my-repo\"\n    importpath = \"github.com/my-org/miniko\"\n    commitSHA  = \"deadbeef\"\n)\n\nfunc main() {\n    ctx := context.Background()\n\n    b, err := build.NewGo(ctx, \".\",\n        build.WithPlatforms(\"linux/amd64\"), // only build for these platforms.\n        build.WithBaseImages(func(ctx context.Context, _ string) (name.Reference, build.Result, error) {\n            ref := name.MustParseReference(baseImage)\n            base, err := remote.Index(ref, remote.WithContext(ctx))\n            return ref, base, err\n        }))\n    if err != nil {\n        log.Fatalf(\"NewGo: %v\", err)\n    }\n    r, err := b.Build(ctx, importpath)\n    if err != nil {\n        log.Fatalf(\"Build: %v\", err)\n    }\n\n    p, err := publish.NewDefault(targetRepo,                 // publish to example.registry/my-repo\n        publish.WithTags([]string{commitSHA}),               // tag with :deadbeef\n        publish.WithAuthFromKeychain(authn.DefaultKeychain)) // use credentials from ~/.docker/config.json\n    if err != nil {\n        log.Fatalf(\"NewDefault: %v\", err)\n    }\n    ref, err := p.Publish(ctx, r, importpath)\n    if err != nil {\n        log.Fatalf(\"Publish: %v\", err)\n    }\n    fmt.Println(ref.String())\n}\n</code></pre>"},{"location":"advanced/lambda/","title":"AWS Lambda","text":"<p><code>ko</code> can build images that can be deployed as AWS Lambda functions, using Lambda's container support.</p> <p>For best results, use the Go runtime interface client provided by the <code>lambda</code> package.</p> <p>For example:</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"github.com/aws/aws-lambda-go/lambda\"\n)\n\ntype Event struct {\n    Name string `json:\"name\"`\n    // TODO: add other request fields here.\n}\n\nfunc main() {\n    lambda.Start(func(ctx context.Context, event Event) (string, error) {\n        return fmt.Sprintf(\"Hello %s!\", event.Name), nil\n    })\n}\n</code></pre> <p>See AWS's documentation for more information on writing Lambda functions in Go.</p> <p>To deploy to Lambda, you must push to AWS Elastic Container Registry (ECR):</p> <pre><code>KO_DOCKER_REPO=[account-id].dkr.ecr.[region].amazonaws.com/my-repo\nimage=$(ko build ./cmd/app)\n</code></pre> <p>Then, create a Lambda function using the image in ECR:</p> <pre><code>aws lambda create-function \\\n  --function-name hello-world \\\n  --package-type Image \\\n  --code ImageUri=${image} \\\n  --role arn:aws:iam::[account-id]:role/lambda-ex\n</code></pre> <p>See AWS's documentation for more information on deploying Lambda functions using Go container images, including how to configure push access to ECR, and how to configure the IAM role for the function.</p> <p>The base image that <code>ko</code> uses by default supports both x86 and Graviton2 architectures.</p> <p>You can also use the <code>ko</code> Terraform provider to build and deploy Lambda functions as part of your IaC workflow, using the <code>aws_lambda_function</code> resource. See the provider example to get started.</p>"},{"location":"advanced/limitations/","title":"Limitations","text":"<p><code>ko</code> works best when your application has no dependencies on the underlying image.</p> <p>This means <code>ko</code> is ideal when you don't require cgo, and builds are executed with <code>CGO_ENABLED=0</code> by default.</p> <p>To install other OS packages, make those available in your configured base image.</p> <p><code>ko</code> only supports Go applications. For a similar tool targeting Java applications, try Jib. For other languages, try apko and melange.</p>"},{"location":"advanced/linux-capabilities/","title":"Linux Capabilities","text":"<p>In Linux, capabilities are a way to selectively grant privileges to a running process.</p> <p>Docker provides <code>--cap-add</code> and <code>--cap-drop</code> run options to tweak container capabilities, e.g:</p> <pre><code>docker run --cap-add bpf hello-world\n</code></pre> <p>If container runs as a non-root user, capabilities are narrowed by intersecting with file capabilities of the application binary. When building images with a Dockerfile, one typically uses <code>setcap</code> tool to modify file capabilities, e.g: <code>setcap FILE bpf=ep</code>.</p> <p>To set file capabilities with <code>ko</code>, specify <code>linux_capabilities</code> in builds configuration section in your <code>.ko.yaml</code>. Use <code>setcap</code> syntax:</p> <pre><code>builds:\n- id: caps\n  linux_capabilities: bpf=ep\n</code></pre>"},{"location":"advanced/linux-capabilities/#alternative-spelling","title":"Alternative spelling","text":"<pre><code>builds:\n- id: caps\n  linux_capabilities:\n  - cap1\n  - cap2\n  - cap3\n</code></pre> <p>A list of capability names is equivalent to <code>cap1,cap2,cap3=p</code>.</p>"},{"location":"advanced/linux-capabilities/#improving-ux-in-capability-reliant-apps","title":"Improving UX in capability-reliant apps","text":"<p>A capability can be permitted (<code>=p</code>), or both permitted and effective (<code>=ep</code>). Effective capabilities are used for permission checks. A program can promote permitted capability to effective when needed.</p> <pre><code>builds:\n- id: caps\n  linux_capabilities: bpf,perfmon,net_admin=ep\n</code></pre> <p>Initially, <code>=ep</code> might look like a good idea. There's no need to explicitly promote permitted capabilities. Application takes advantage of effective capabilities right away.</p> <p>There is a catch though.</p> <pre><code>$ docker run --cap-add bpf ko.local/caps.test-4b8f7bca75c467b3d2803e1c087a3287\nexec /ko-app/caps.test: operation not permitted\n</code></pre> <p>When run options request fewer capabilities than specified in file capabilities, container fails to start. It is hard to tell what went wrong since <code>operation not permitted</code> is a generic error. (Docker is unlikely to improve diagnostics for this failure case since the check is implemented in Linux kernel.)</p> <p>We suggest to use <code>=p</code> instead. This option puts application in charge of verifying and promoting permitted capabilities to effective. It can produce much better diagnostics:</p> <pre><code>$ docker run --cap-add bpf ko.local/caps.test-4b8f7bca75c467b3d2803e1c087a3287\ncurrent capabilities: cap_bpf=p\nactivating capabilities: cap_net_admin,cap_perfmon,cap_bpf=ep: operation not permitted\n</code></pre> <p>Sample code.</p>"},{"location":"advanced/migrating-from-dockerfile/","title":"Migrating from Dockerfile","text":"<p>If your <code>Dockerfile</code> looks like either of the examples in the official tutorial for writing a Dockerfile to containerize a Go application, you can easily migrate to use <code>ko</code> instead.</p> <p>Let's review the best practice multi-stage Dockerfile in that tutorial first:</p> <pre><code>## Build\nFROM golang:1.16-buster AS build\n\nWORKDIR /app\n\nCOPY go.mod ./\nCOPY go.sum ./\nRUN go mod download\n\nCOPY *.go ./\n\nRUN go build -o /docker-gs-ping\n\n## Deploy\nFROM gcr.io/distroless/base-debian10\n\nWORKDIR /\n\nCOPY --from=build /docker-gs-ping /docker-gs-ping\n\nEXPOSE 8080\n\nUSER nonroot:nonroot\n\nENTRYPOINT [\"/docker-gs-ping\"]\n</code></pre> <p>This <code>Dockerfile</code>:</p> <ol> <li>pulls the <code>golang:1.16</code> image</li> <li><code>COPY</code>s your local source into the container environment (<code>COPY</code>ing <code>go.mod</code> and <code>go.sum</code> first and running <code>go mod download</code>, to cache dependencies in the container environment)</li> <li><code>RUN</code>s <code>go build</code> on your source, inside the container, to produce an executable</li> <li><code>COPY</code>s the executable built in the previous step into a new image, on top of a minimal distroless base image.</li> </ol> <p>The result is a Go application built on a minimal base image, with an optimally cached build sequence.</p> <p>After running <code>docker build</code> on this <code>Dockerfile</code>, don't forget to push that image to the registry so you can deploy it.</p>"},{"location":"advanced/migrating-from-dockerfile/#migrating-to-ko","title":"Migrating to <code>ko</code>","text":"<p>If your\u00a0Go source is laid out as described in the tutorial, and you've installed and set up your environment, you can simply run <code>ko build ./</code> to build and push the container image to your registry.</p> <p>You're done. You can delete your <code>Dockerfile</code> and uninstall <code>docker</code>.</p> <p><code>ko</code> takes advantage of your local Go build cache without needing to be told to, and it sets the <code>ENTRYPOINT</code> and uses a nonroot distroless base image by default.</p> <p>To build a multi-arch image, simply add <code>--platform=all</code>. Compare this to the equivalent Docker instructions.</p>"},{"location":"advanced/root-ca-certificates/","title":"Root CA Certificates","text":"<p>To install a root certificate into your container built using <code>ko</code>, you can use one of the following methods.</p>"},{"location":"advanced/root-ca-certificates/#incert","title":"incert","text":"<p><code>incert</code> allows you to append CA certificates to an image and push the modified image to a specified registry.</p> <p><code>incert</code> can be run after <code>ko build</code> to build your Go application container image with custom root CA certificates.</p>"},{"location":"advanced/root-ca-certificates/#example","title":"Example","text":"<ol> <li> <p>Build and push your Go application container image using <code>ko build</code> <pre><code>KO_DOCKER_REPO=mycompany/myimage:latest ko build .\n</code></pre></p> </li> <li> <p>Append the built image with your custom CA certificate(s) using <code>incert</code> <pre><code>incert -image-url=mycompany/myimage:latest -ca-certs-file=/path/to/cacerts.pem -dest-image-url=myregistry/myimage:latest\n</code></pre></p> </li> </ol>"},{"location":"advanced/root-ca-certificates/#custom-base-image","title":"Custom Base Image","text":"<p>New root certificates can be installed into a custom image using standard OS packages. Then, this custom image can be used to override the base image for <code>ko</code>. Once the Go application container image is built using <code>ko</code> with the custom base image, the root certificates installed on the base image will be trusted by the Go application.</p>"},{"location":"advanced/root-ca-certificates/#example_1","title":"Example","text":"<ol> <li> <p>Make a custom container image with your new root certificates <pre><code># Dockerfile\nFROM alpine\n\nRUN apk update\nRUN apk add ca-certificates\n\nADD new-root-ca.crt /usr/local/share/ca-certificates/new-root-ca.crt\nRUN chmod 644 /usr/local/share/ca-certificates/new-root-ca.crt\nRUN update-ca-certificates\n</code></pre></p> </li> <li> <p>Build and push the custom container image to a container registry <pre><code>docker build . -t docker.io/ko-build/image-with-new-root-certs\ndocker push docker.io/ko-build/image-with-new-root-certs\n</code></pre></p> </li> <li> <p>Configure <code>ko</code> to override the default base image with the custom image <pre><code># .ko.yaml\ndefaultBaseImage: docker.io/ko-build/image-with-new-root-certs\n</code></pre></p> <p>OR <pre><code>export KO_DEFAULTBASEIMAGE=docker.io/ko-build/image-with-new-root-certs\n</code></pre></p> </li> <li> <p>Build the Go app container image with <code>ko</code> <pre><code>ko build .\n</code></pre></p> </li> </ol>"},{"location":"advanced/root-ca-certificates/#static-assets","title":"Static Assets","text":"<p>Alternatively, root certificates can be installed into the Go application container image using a combination of <code>ko</code> static assets and overriding the default system location for SSL certificates.</p> <p>Using <code>ko</code>'s support for static assets, root certificates can be stored in the <code>&lt;importpath&gt;/kodata</code> directory (either checked into the repository, or injected dynamically by a CI pipeline). After running <code>ko build</code>, the certificate files are then bundled into the built image at the path <code>$KO_DATA_PATH</code>.</p> <p>To enable the Go application to trust the bundled certificate(s), the container runtime or orchestrator (Docker, Kubernetes, etc) must set the environment variable <code>SSL_CERT_DIR</code> to the same value as <code>KO_DATA_PATH</code>. Go uses <code>SSL_CERT_DIR</code> to determine the directory to check for SSL certificate files. Once this variable is set, the Go application will trust the bundled root certificates in <code>$KO_DATA_PATH</code>.</p>"},{"location":"advanced/root-ca-certificates/#example_2","title":"Example","text":"<ol> <li> <p>Copy the root certificate(s) to the <code>&lt;importpath&gt;/kodata/</code> directory <pre><code># $(pwd) assumed to be at &lt;importpath&gt; for this example\nmkdir -p kodata\ncp $CERT_FILE_DIR/*.crt kodata/\n</code></pre></p> </li> <li> <p>Build the Go application container image <pre><code>KO_DOCKER_REPO=docker.io/ko-build/static-assets-certs ko build .\n</code></pre></p> </li> <li> <p>Run the Go application container image with <code>SSL_CERT_DIR</code> equal to <code>/var/run/ko</code> (the default value for <code>$KO_DATA_PATH</code>) <pre><code>docker run -e SSL_CERT_DIR=/var/run/ko docker.io/ko-build/static-assets-certs\n</code></pre></p> </li> </ol> <p>A functional client-server example for this can be seen here.</p>"},{"location":"advanced/terraform/","title":"Terraform Provider","text":"<p>In addition to the CLI, <code>ko</code>'s functionality is also available as a Terraform provider.</p> <p>This allows <code>ko</code> to be integrated with your Infrastructure-as-Code (IaC) workflows, and makes building your code a seamless part of your deployment process.</p> <p>Using the Terraform provider is as simple as adding a <code>ko_build</code> resource to your Terraform configuration:</p> <pre><code>// Require the `ko-build/ko` provider.\nterraform {\n  required_providers {\n    ko = { source = \"ko-build/ko\" }\n  }\n}\n\n// Configure the provider to push to your repo.\nprovider \"ko\" {\n  repo = \"example.registry/my-repo\" // equivalent to KO_DOCKER_REPO\n}\n\n// Build your code.\nresource \"ko_build\" \"app\" {\n  importpath = \"github.com/example/repo/cmd/app\"\n}\n\n// TODO: use the `ko_build.app` resource elsewhere in your Terraform configuration.\n\n// Report the build image's digest.\noutput \"image\" {\n  value = ko_build.app.image_ref\n}\n</code></pre> <p>See the <code>ko-build/ko</code> provider on the Terraform Registry for more information, and the GitHub repo for more examples.</p>"},{"location":"features/build-cache/","title":"Build Cache","text":"<p>Because <code>ko</code> just runs <code>go build</code> in your normal development environment, it automatically reuses your <code>go build</code> cache from previous builds, making iterative development faster.</p> <p><code>ko</code> also avoids pushing blobs to the remote image registry if they're already present, making pushes faster.</p> <p>You can make <code>ko</code> even faster by setting the <code>KOCACHE</code> environment variable. This tells <code>ko</code> to store a local mapping between the <code>go build</code> inputs to the image layer that they produce, so <code>go build</code> can be skipped entirely if the layer is already present in the image registry.</p>"},{"location":"features/debugging/","title":"Debugging","text":"<p>Sometimes it's challenging to track down the cause of unexpected behavior in an app. Because <code>ko</code> makes it simple to make tweaks to your app and immediately rebuild your image, it's possible to iteratively explore various aspects of your app, such as by adding log lines that print variable values.</p> <p>But to help you solve the problem as fast as possible, <code>ko</code> supports debugging your Go app with delve.</p> <p>To use this feature, just add the <code>--debug</code> flag to your <code>ko build</code> command. This adjusts how the image is built:</p> <ul> <li>It installs <code>delve</code> in the image (in addition to your own app).</li> <li>It sets the image's <code>ENTRYPOINT</code> to a <code>delve exec ...</code> command that runs the Go app in debug-mode, listening on port <code>40000</code> for a debugger client.</li> <li>It ensures your compiled Go app includes debug symbols needed to enable debugging.</li> </ul> <p>Note: This feature is geared toward development workflows. It should not be used in production.</p>"},{"location":"features/debugging/#how-it-works","title":"How it works","text":"<p>Build the image using the debug feature.</p> <pre><code>ko build . --debug\n</code></pre> <p>Run the container, ensuring that the debug port (<code>40000</code>) is exposed to allow clients to connect to it.</p> <pre><code>docker run -p 40000:40000 &lt;img&gt;\n</code></pre> <p>This sets up your app to be waiting to run the command you've specified. All that's needed now is to connect your debugger client to the running container!</p>"},{"location":"features/k8s/","title":"Kubernetes Integration","text":"<p>You could stop at just building and pushing images.</p> <p>But, because building images is so easy with <code>ko</code>, and because building with <code>ko</code> only requires a string importpath to identify the image, we can integrate this with YAML generation to make Kubernetes use cases much simpler.</p>"},{"location":"features/k8s/#yaml-changes","title":"YAML Changes","text":"<p>Traditionally, you might have a Kubernetes deployment, defined in a YAML file, that runs an image:</p> <pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: my-deployment\nspec:\n  selector:\n    matchLabels:\n      app: my-app\n  template:\n    metadata:\n      labels:\n        app: my-app\n    spec:\n      containers:\n      - name: my-app\n        image: registry.example.com/my-app:v1.2.3\n</code></pre> <p>...which you apply to your cluster with <code>kubectl apply</code>:</p> <pre><code>kubectl apply -f deployment.yaml\n</code></pre> <p>With <code>ko</code>, you can instead reference your Go binary by its importpath, prefixed with <code>ko://</code>:</p> <pre><code>    ...\n    spec:\n      containers:\n      - name: my-app\n        image: ko://github.com/my-user/my-repo/cmd/app\n</code></pre>"},{"location":"features/k8s/#ko-resolve","title":"<code>ko resolve</code>","text":"<p>With this small change, running <code>ko resolve -f deployment.yaml</code> will instruct <code>ko</code> to:</p> <ol> <li>scan the YAML file(s) for values with the <code>ko://</code> prefix,</li> <li>for each unique <code>ko://</code>-prefixed string, execute <code>ko build &lt;importpath&gt;</code> to    build and push an image,</li> <li>replace <code>ko://</code>-prefixed string(s) in the input YAML with the fully-specified    image reference of the built image(s), as above.</li> <li>Print the resulting resolved YAML to stdout.</li> </ol> <p>The result can be redirected to a file, to distribute to others:</p> <pre><code>ko resolve -f config/ &gt; release.yaml\n</code></pre> <p>Taken together, <code>ko resolve</code> aims to make packaging, pushing, and referencing container images an invisible implementation detail of your Kubernetes deployment, and let you focus on writing code in Go.</p>"},{"location":"features/k8s/#ko-apply","title":"<code>ko apply</code>","text":"<p>To apply the resulting resolved YAML config, you can redirect the output of <code>ko resolve</code> to <code>kubectl apply</code>:</p> <pre><code>ko resolve -f config/ | kubectl apply -f -\n</code></pre> <p>Since this is a relatively common use case, the same functionality is available using <code>ko apply</code>:</p> <pre><code>ko apply -f config/\n</code></pre> <p>Also, any flags passed after <code>--</code> are passed to <code>kubectl apply</code> directly, for example to specify context and kubeconfig: <pre><code>ko apply -f config -- --context=foo --kubeconfig=cfg.yaml\n</code></pre></p> <p>NB: This requires that <code>kubectl</code> is available.</p>"},{"location":"features/k8s/#ko-delete","title":"<code>ko delete</code>","text":"<p>To teardown resources applied using <code>ko apply</code>, you can run <code>ko delete</code>:</p> <pre><code>ko delete -f config/\n</code></pre> <p>This is purely a convenient alias for <code>kubectl delete</code>, and doesn't perform any builds, or delete any previously built images.</p>"},{"location":"features/multi-platform/","title":"Multi-Platform Images","text":"<p>Because Go supports cross-compilation to other CPU architectures and operating systems, <code>ko</code> excels at producing multi-platform images.</p> <p>To build and push an image for all platforms supported by the configured base image, simply add <code>--platform=all</code>. This will instruct <code>ko</code> to look up all the supported platforms in the base image, execute <code>GOOS=&lt;os&gt; GOARCH=&lt;arch&gt; GOARM=&lt;variant&gt; go build</code> for each platform, and produce a manifest list containing an image for each platform.</p> <p>You can also select specific platforms, for example, <code>--platform=linux/amd64,linux/arm64</code>.</p> <p><code>ko</code> also has experimental support for building for Windows images. See FAQ.</p>"},{"location":"features/sboms/","title":"SBOMs","text":"<p>A Software Bill of Materials (SBOM) is a list of software components that a software artifact depends on. Having a list of dependencies can be helpful in determining whether any vulnerable components were used to build the software artifact.</p> <p>From v0.9+, <code>ko</code> generates and uploads an SBOM for every image it produces by default.</p> <p>ko will generate an SBOM in the SPDX format by default. To disable SBOM generation, pass <code>--sbom=none</code>.</p> <p>These SBOMs can be downloaded using the <code>cosign download sbom</code> command.</p>"},{"location":"features/static-assets/","title":"Static Assets","text":"<p><code>ko</code> can also bundle static assets into the images it produces.</p> <p>By convention, any contents of a directory named <code>&lt;importpath&gt;/kodata/</code> will be bundled into the image, and the path where it's available in the image will be identified by the environment variable <code>KO_DATA_PATH</code>.</p> <p>As an example, you can bundle and serve static contents in your image:</p> <pre><code>cmd/\n  app/\n    main.go\n    kodata/\n      favicon.ico\n      index.html\n</code></pre> <p>Then, in your <code>main.go</code>:</p> <pre><code>func main() {\n    http.Handle(\"/\", http.FileServer(http.Dir(os.Getenv(\"KO_DATA_PATH\"))))\n    log.Fatal(http.ListenAndServe(\":8080\", nil))\n}\n</code></pre> <p>You can simulate <code>ko</code>'s behavior outside of the container image by setting the <code>KO_DATA_PATH</code> environment variable yourself with <code>KO_DATA_PATH=cmd/app/kodata/ go run ./cmd/app</code>.</p> <p>\ud83d\udca1 Tip: Symlinks in <code>kodata</code> are followed and included as well. For example, you can include Git commit information in your image with <code>ln -s -r .git/HEAD ./cmd/app/kodata/</code></p> <p>Also note that <code>http.FileServer</code> will not serve the <code>Last-Modified</code> header (or validate <code>If-Modified-Since</code> request headers) because <code>ko</code> does not embed timestamps by default.</p> <p>This can be supported by manually setting the <code>KO_DATA_DATE_EPOCH</code> environment variable during build (See FAQ).</p>"},{"location":"reference/ko/","title":"ko","text":""},{"location":"reference/ko/#ko","title":"ko","text":"<p>Rapidly iterate with Go, Containers, and Kubernetes.</p> <pre><code>ko [flags]\n</code></pre>"},{"location":"reference/ko/#options","title":"Options","text":"<pre><code>  -h, --help      help for ko\n  -v, --verbose   Enable debug logs\n</code></pre>"},{"location":"reference/ko/#see-also","title":"SEE ALSO","text":"<ul> <li>ko apply    - Apply the input files with image references resolved to built/pushed image digests.</li> <li>ko build    - Build and publish container images from the given importpaths.</li> <li>ko create  - Create the input files with image references resolved to built/pushed image digests.</li> <li>ko delete  - See \"kubectl help delete\" for detailed usage.</li> <li>ko login    - Log in to a registry</li> <li>ko resolve    - Print the input files with image references resolved to built/pushed image digests.</li> <li>ko run    - A variant of <code>kubectl run</code> that containerizes IMPORTPATH first.</li> <li>ko version    - Print ko version.</li> </ul>"},{"location":"reference/ko_apply/","title":"ko apply","text":""},{"location":"reference/ko_apply/#ko-apply","title":"ko apply","text":"<p>Apply the input files with image references resolved to built/pushed image digests.</p>"},{"location":"reference/ko_apply/#synopsis","title":"Synopsis","text":"<p>This sub-command finds import path references within the provided files, builds them into Go binaries, containerizes them, publishes them, and then feeds the resulting yaml into \"kubectl apply\".</p> <pre><code>ko apply -f FILENAME [flags]\n</code></pre>"},{"location":"reference/ko_apply/#examples","title":"Examples","text":"<pre><code>  # Build and publish import path references to a Docker\n  # Registry as:\n  #   ${KO_DOCKER_REPO}/&lt;package name&gt;-&lt;hash of import path&gt;\n  # Then, feed the resulting yaml into \"kubectl apply\".\n  # When KO_DOCKER_REPO is ko.local, it is the same as if\n  # --local was passed.\n  ko apply -f config/\n\n  # Build and publish import path references to a Docker\n  # Registry preserving import path names as:\n  #   ${KO_DOCKER_REPO}/&lt;import path&gt;\n  # Then, feed the resulting yaml into \"kubectl apply\".\n  ko apply --preserve-import-paths -f config/\n\n  # Build and publish import path references to a Docker\n  # daemon as:\n  #   ko.local/&lt;import path&gt;\n  # Then, feed the resulting yaml into \"kubectl apply\".\n  ko apply --local -f config/\n\n  # Apply from stdin:\n  cat config.yaml | ko apply -f -\n\n  # Any flags passed after '--' are passed to 'kubectl apply' directly:\n  ko apply -f config -- --namespace=foo --kubeconfig=cfg.yaml\n</code></pre>"},{"location":"reference/ko_apply/#options","title":"Options","text":"<pre><code>      --bare                       Whether to just use KO_DOCKER_REPO without additional context (may not work properly with --tags).\n  -B, --base-import-paths          Whether to use the base path without MD5 hash after KO_DOCKER_REPO (may not work properly with --tags).\n      --debug                      Include Delve debugger into image and wrap around ko-app. This debugger will listen to port 40000.\n      --disable-optimizations      Disable optimizations when building Go code. Useful when you want to interactively debug the created container.\n  -f, --filename strings           Filename, directory, or URL to files to use to create the resource\n  -h, --help                       help for apply\n      --image-annotation strings   Which annotations (key=value[,key=value]) to add to the OCI manifest.\n      --image-label strings        Which labels (key=value[,key=value]) to add to the image.\n      --image-refs string          Path to file where a list of the published image references will be written.\n      --image-user string          The default user the image should be run as.\n      --insecure-registry          Whether to skip TLS verification on the registry\n  -j, --jobs int                   The maximum number of concurrent builds (default GOMAXPROCS)\n  -L, --local                      Load into images to local docker daemon.\n      --oci-layout-path string     Path to save the OCI image layout of the built images\n      --platform strings           Which platform to use when pulling a multi-platform base. Format: all | &lt;os&gt;[/&lt;arch&gt;[/&lt;variant&gt;]][,platform]*\n  -P, --preserve-import-paths      Whether to preserve the full import path after KO_DOCKER_REPO.\n      --push                       Push images to KO_DOCKER_REPO (default true)\n  -R, --recursive                  Process the directory used in -f, --filename recursively. Useful when you want to manage related manifests organized within the same directory.\n      --sbom string                The SBOM media type to use (none will disable SBOM synthesis and upload). (default \"spdx\")\n      --sbom-dir string            Path to file where the SBOM will be written.\n  -l, --selector string            Selector (label query) to filter on, supports '=', '==', and '!='.(e.g. -l key1=value1,key2=value2)\n      --tag-only                   Include tags but not digests in resolved image references. Useful when digests are not preserved when images are repopulated.\n  -t, --tags strings               Which tags to use for the produced image instead of the default 'latest' tag (may not work properly with --base-import-paths or --bare). (default [latest])\n      --tarball string             File to save images tarballs\n</code></pre>"},{"location":"reference/ko_apply/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>  -v, --verbose   Enable debug logs\n</code></pre>"},{"location":"reference/ko_apply/#see-also","title":"SEE ALSO","text":"<ul> <li>ko    - Rapidly iterate with Go, Containers, and Kubernetes.</li> </ul>"},{"location":"reference/ko_build/","title":"ko build","text":""},{"location":"reference/ko_build/#ko-build","title":"ko build","text":"<p>Build and publish container images from the given importpaths.</p>"},{"location":"reference/ko_build/#synopsis","title":"Synopsis","text":"<p>This sub-command builds the provided import paths into Go binaries, containerizes them, and publishes them.</p> <pre><code>ko build IMPORTPATH... [flags]\n</code></pre>"},{"location":"reference/ko_build/#examples","title":"Examples","text":"<pre><code>  # Build and publish import path references to a Docker Registry as:\n  #   ${KO_DOCKER_REPO}/&lt;package name&gt;-&lt;hash of import path&gt;\n  # When KO_DOCKER_REPO is ko.local, it is the same as if --local and\n  # --preserve-import-paths were passed.\n  # If the import path is not provided, the current working directory is the\n  # default.\n  ko build github.com/foo/bar/cmd/baz github.com/foo/bar/cmd/blah\n\n  # Build and publish a relative import path as:\n  #   ${KO_DOCKER_REPO}/&lt;package name&gt;-&lt;hash of import path&gt;\n  # When KO_DOCKER_REPO is ko.local, it is the same as if --local and\n  # --preserve-import-paths were passed.\n  ko build ./cmd/blah\n\n  # Build and publish a relative import path as:\n  #   ${KO_DOCKER_REPO}/&lt;import path&gt;\n  # When KO_DOCKER_REPO is ko.local, it is the same as if --local was passed.\n  ko build --preserve-import-paths ./cmd/blah\n\n  # Build and publish import path references to a Docker daemon as:\n  #   ko.local/&lt;import path&gt;\n  # This always preserves import paths.\n  ko build --local github.com/foo/bar/cmd/baz github.com/foo/bar/cmd/blah\n</code></pre>"},{"location":"reference/ko_build/#options","title":"Options","text":"<pre><code>      --bare                       Whether to just use KO_DOCKER_REPO without additional context (may not work properly with --tags).\n  -B, --base-import-paths          Whether to use the base path without MD5 hash after KO_DOCKER_REPO (may not work properly with --tags).\n      --debug                      Include Delve debugger into image and wrap around ko-app. This debugger will listen to port 40000.\n      --disable-optimizations      Disable optimizations when building Go code. Useful when you want to interactively debug the created container.\n  -h, --help                       help for build\n      --image-annotation strings   Which annotations (key=value[,key=value]) to add to the OCI manifest.\n      --image-label strings        Which labels (key=value[,key=value]) to add to the image.\n      --image-refs string          Path to file where a list of the published image references will be written.\n      --image-user string          The default user the image should be run as.\n      --insecure-registry          Whether to skip TLS verification on the registry\n  -j, --jobs int                   The maximum number of concurrent builds (default GOMAXPROCS)\n  -L, --local                      Load into images to local docker daemon.\n      --oci-layout-path string     Path to save the OCI image layout of the built images\n      --platform strings           Which platform to use when pulling a multi-platform base. Format: all | &lt;os&gt;[/&lt;arch&gt;[/&lt;variant&gt;]][,platform]*\n  -P, --preserve-import-paths      Whether to preserve the full import path after KO_DOCKER_REPO.\n      --push                       Push images to KO_DOCKER_REPO (default true)\n      --sbom string                The SBOM media type to use (none will disable SBOM synthesis and upload). (default \"spdx\")\n      --sbom-dir string            Path to file where the SBOM will be written.\n      --tag-only                   Include tags but not digests in resolved image references. Useful when digests are not preserved when images are repopulated.\n  -t, --tags strings               Which tags to use for the produced image instead of the default 'latest' tag (may not work properly with --base-import-paths or --bare). (default [latest])\n      --tarball string             File to save images tarballs\n</code></pre>"},{"location":"reference/ko_build/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>  -v, --verbose   Enable debug logs\n</code></pre>"},{"location":"reference/ko_build/#see-also","title":"SEE ALSO","text":"<ul> <li>ko    - Rapidly iterate with Go, Containers, and Kubernetes.</li> </ul>"},{"location":"reference/ko_create/","title":"ko create","text":""},{"location":"reference/ko_create/#ko-create","title":"ko create","text":"<p>Create the input files with image references resolved to built/pushed image digests.</p>"},{"location":"reference/ko_create/#synopsis","title":"Synopsis","text":"<p>This sub-command finds import path references within the provided files, builds them into Go binaries, containerizes them, publishes them, and then feeds the resulting yaml into \"kubectl create\".</p> <pre><code>ko create -f FILENAME [flags]\n</code></pre>"},{"location":"reference/ko_create/#examples","title":"Examples","text":"<pre><code>  # Build and publish import path references to a Docker\n  # Registry as:\n  #   ${KO_DOCKER_REPO}/&lt;package name&gt;-&lt;hash of import path&gt;\n  # Then, feed the resulting yaml into \"kubectl create\".\n  # When KO_DOCKER_REPO is ko.local, it is the same as if\n  # --local was passed.\n  ko create -f config/\n\n  # Build and publish import path references to a Docker\n  # Registry preserving import path names as:\n  #   ${KO_DOCKER_REPO}/&lt;import path&gt;\n  # Then, feed the resulting yaml into \"kubectl create\".\n  ko create --preserve-import-paths -f config/\n\n  # Build and publish import path references to a Docker\n  # daemon as:\n  #   ko.local/&lt;import path&gt;\n  # Then, feed the resulting yaml into \"kubectl create\".\n  ko create --local -f config/\n\n  # Create from stdin:\n  cat config.yaml | ko create -f -\n\n  # Any flags passed after '--' are passed to 'kubectl apply' directly:\n  ko apply -f config -- --namespace=foo --kubeconfig=cfg.yaml\n</code></pre>"},{"location":"reference/ko_create/#options","title":"Options","text":"<pre><code>      --bare                       Whether to just use KO_DOCKER_REPO without additional context (may not work properly with --tags).\n  -B, --base-import-paths          Whether to use the base path without MD5 hash after KO_DOCKER_REPO (may not work properly with --tags).\n      --debug                      Include Delve debugger into image and wrap around ko-app. This debugger will listen to port 40000.\n      --disable-optimizations      Disable optimizations when building Go code. Useful when you want to interactively debug the created container.\n  -f, --filename strings           Filename, directory, or URL to files to use to create the resource\n  -h, --help                       help for create\n      --image-annotation strings   Which annotations (key=value[,key=value]) to add to the OCI manifest.\n      --image-label strings        Which labels (key=value[,key=value]) to add to the image.\n      --image-refs string          Path to file where a list of the published image references will be written.\n      --image-user string          The default user the image should be run as.\n      --insecure-registry          Whether to skip TLS verification on the registry\n  -j, --jobs int                   The maximum number of concurrent builds (default GOMAXPROCS)\n  -L, --local                      Load into images to local docker daemon.\n      --oci-layout-path string     Path to save the OCI image layout of the built images\n      --platform strings           Which platform to use when pulling a multi-platform base. Format: all | &lt;os&gt;[/&lt;arch&gt;[/&lt;variant&gt;]][,platform]*\n  -P, --preserve-import-paths      Whether to preserve the full import path after KO_DOCKER_REPO.\n      --push                       Push images to KO_DOCKER_REPO (default true)\n  -R, --recursive                  Process the directory used in -f, --filename recursively. Useful when you want to manage related manifests organized within the same directory.\n      --sbom string                The SBOM media type to use (none will disable SBOM synthesis and upload). (default \"spdx\")\n      --sbom-dir string            Path to file where the SBOM will be written.\n  -l, --selector string            Selector (label query) to filter on, supports '=', '==', and '!='.(e.g. -l key1=value1,key2=value2)\n      --tag-only                   Include tags but not digests in resolved image references. Useful when digests are not preserved when images are repopulated.\n  -t, --tags strings               Which tags to use for the produced image instead of the default 'latest' tag (may not work properly with --base-import-paths or --bare). (default [latest])\n      --tarball string             File to save images tarballs\n</code></pre>"},{"location":"reference/ko_create/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>  -v, --verbose   Enable debug logs\n</code></pre>"},{"location":"reference/ko_create/#see-also","title":"SEE ALSO","text":"<ul> <li>ko    - Rapidly iterate with Go, Containers, and Kubernetes.</li> </ul>"},{"location":"reference/ko_delete/","title":"ko delete","text":""},{"location":"reference/ko_delete/#ko-delete","title":"ko delete","text":"<p>See \"kubectl help delete\" for detailed usage.</p> <pre><code>ko delete [flags]\n</code></pre>"},{"location":"reference/ko_delete/#options","title":"Options","text":"<pre><code>  -h, --help   help for delete\n</code></pre>"},{"location":"reference/ko_delete/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>  -v, --verbose   Enable debug logs\n</code></pre>"},{"location":"reference/ko_delete/#see-also","title":"SEE ALSO","text":"<ul> <li>ko    - Rapidly iterate with Go, Containers, and Kubernetes.</li> </ul>"},{"location":"reference/ko_login/","title":"ko login","text":""},{"location":"reference/ko_login/#ko-login","title":"ko login","text":"<p>Log in to a registry</p> <pre><code>ko login [OPTIONS] [SERVER] [flags]\n</code></pre>"},{"location":"reference/ko_login/#examples","title":"Examples","text":"<pre><code>  # Log in to reg.example.com\n  ko login reg.example.com -u AzureDiamond -p hunter2\n</code></pre>"},{"location":"reference/ko_login/#options","title":"Options","text":"<pre><code>  -h, --help              help for login\n  -p, --password string   Password\n      --password-stdin    Take the password from stdin\n  -u, --username string   Username\n</code></pre>"},{"location":"reference/ko_login/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>  -v, --verbose   Enable debug logs\n</code></pre>"},{"location":"reference/ko_login/#see-also","title":"SEE ALSO","text":"<ul> <li>ko    - Rapidly iterate with Go, Containers, and Kubernetes.</li> </ul>"},{"location":"reference/ko_resolve/","title":"ko resolve","text":""},{"location":"reference/ko_resolve/#ko-resolve","title":"ko resolve","text":"<p>Print the input files with image references resolved to built/pushed image digests.</p>"},{"location":"reference/ko_resolve/#synopsis","title":"Synopsis","text":"<p>This sub-command finds import path references within the provided files, builds them into Go binaries, containerizes them, publishes them, and prints the resulting yaml.</p> <pre><code>ko resolve -f FILENAME [flags]\n</code></pre>"},{"location":"reference/ko_resolve/#examples","title":"Examples","text":"<pre><code>  # Build and publish import path references to a Docker\n  # Registry as:\n  #   ${KO_DOCKER_REPO}/&lt;package name&gt;-&lt;hash of import path&gt;\n  # When KO_DOCKER_REPO is ko.local, it is the same as if\n  # --local and --preserve-import-paths were passed.\n  ko resolve -f config/\n\n  # Build and publish import path references to a Docker\n  # Registry preserving import path names as:\n  #   ${KO_DOCKER_REPO}/&lt;import path&gt;\n  # When KO_DOCKER_REPO is ko.local, it is the same as if\n  # --local was passed.\n  ko resolve --preserve-import-paths -f config/\n\n  # Build and publish import path references to a Docker\n  # daemon as:\n  #   ko.local/&lt;import path&gt;\n  # This always preserves import paths.\n  ko resolve --local -f config/\n</code></pre>"},{"location":"reference/ko_resolve/#options","title":"Options","text":"<pre><code>      --bare                       Whether to just use KO_DOCKER_REPO without additional context (may not work properly with --tags).\n  -B, --base-import-paths          Whether to use the base path without MD5 hash after KO_DOCKER_REPO (may not work properly with --tags).\n      --debug                      Include Delve debugger into image and wrap around ko-app. This debugger will listen to port 40000.\n      --disable-optimizations      Disable optimizations when building Go code. Useful when you want to interactively debug the created container.\n  -f, --filename strings           Filename, directory, or URL to files to use to create the resource\n  -h, --help                       help for resolve\n      --image-annotation strings   Which annotations (key=value[,key=value]) to add to the OCI manifest.\n      --image-label strings        Which labels (key=value[,key=value]) to add to the image.\n      --image-refs string          Path to file where a list of the published image references will be written.\n      --image-user string          The default user the image should be run as.\n      --insecure-registry          Whether to skip TLS verification on the registry\n  -j, --jobs int                   The maximum number of concurrent builds (default GOMAXPROCS)\n  -L, --local                      Load into images to local docker daemon.\n      --oci-layout-path string     Path to save the OCI image layout of the built images\n      --platform strings           Which platform to use when pulling a multi-platform base. Format: all | &lt;os&gt;[/&lt;arch&gt;[/&lt;variant&gt;]][,platform]*\n  -P, --preserve-import-paths      Whether to preserve the full import path after KO_DOCKER_REPO.\n      --push                       Push images to KO_DOCKER_REPO (default true)\n  -R, --recursive                  Process the directory used in -f, --filename recursively. Useful when you want to manage related manifests organized within the same directory.\n      --sbom string                The SBOM media type to use (none will disable SBOM synthesis and upload). (default \"spdx\")\n      --sbom-dir string            Path to file where the SBOM will be written.\n  -l, --selector string            Selector (label query) to filter on, supports '=', '==', and '!='.(e.g. -l key1=value1,key2=value2)\n      --tag-only                   Include tags but not digests in resolved image references. Useful when digests are not preserved when images are repopulated.\n  -t, --tags strings               Which tags to use for the produced image instead of the default 'latest' tag (may not work properly with --base-import-paths or --bare). (default [latest])\n      --tarball string             File to save images tarballs\n</code></pre>"},{"location":"reference/ko_resolve/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>  -v, --verbose   Enable debug logs\n</code></pre>"},{"location":"reference/ko_resolve/#see-also","title":"SEE ALSO","text":"<ul> <li>ko    - Rapidly iterate with Go, Containers, and Kubernetes.</li> </ul>"},{"location":"reference/ko_run/","title":"ko run","text":""},{"location":"reference/ko_run/#ko-run","title":"ko run","text":"<p>A variant of <code>kubectl run</code> that containerizes IMPORTPATH first.</p>"},{"location":"reference/ko_run/#synopsis","title":"Synopsis","text":"<p>This sub-command combines \"ko build\" and \"kubectl run\" to support containerizing and running Go binaries on Kubernetes in a single command.</p> <pre><code>ko run IMPORTPATH [flags]\n</code></pre>"},{"location":"reference/ko_run/#examples","title":"Examples","text":"<pre><code>  # Publish the image and run it on Kubernetes as:\n  #   ${KO_DOCKER_REPO}/&lt;package name&gt;-&lt;hash of import path&gt;\n  # When KO_DOCKER_REPO is ko.local, it is the same as if\n  # --local and --preserve-import-paths were passed.\n  ko run github.com/foo/bar/cmd/baz\n\n  # This supports relative import paths as well.\n  ko run ./cmd/baz\n\n  # You can also supply args and flags to the command.\n  ko run ./cmd/baz -- -v arg1 arg2 --yes\n</code></pre>"},{"location":"reference/ko_run/#options","title":"Options","text":"<pre><code>      --bare                       Whether to just use KO_DOCKER_REPO without additional context (may not work properly with --tags).\n  -B, --base-import-paths          Whether to use the base path without MD5 hash after KO_DOCKER_REPO (may not work properly with --tags).\n      --debug                      Include Delve debugger into image and wrap around ko-app. This debugger will listen to port 40000.\n      --disable-optimizations      Disable optimizations when building Go code. Useful when you want to interactively debug the created container.\n  -h, --help                       help for run\n      --image-annotation strings   Which annotations (key=value[,key=value]) to add to the OCI manifest.\n      --image-label strings        Which labels (key=value[,key=value]) to add to the image.\n      --image-refs string          Path to file where a list of the published image references will be written.\n      --image-user string          The default user the image should be run as.\n      --insecure-registry          Whether to skip TLS verification on the registry\n  -j, --jobs int                   The maximum number of concurrent builds (default GOMAXPROCS)\n  -L, --local                      Load into images to local docker daemon.\n      --oci-layout-path string     Path to save the OCI image layout of the built images\n      --platform strings           Which platform to use when pulling a multi-platform base. Format: all | &lt;os&gt;[/&lt;arch&gt;[/&lt;variant&gt;]][,platform]*\n  -P, --preserve-import-paths      Whether to preserve the full import path after KO_DOCKER_REPO.\n      --push                       Push images to KO_DOCKER_REPO (default true)\n      --sbom string                The SBOM media type to use (none will disable SBOM synthesis and upload). (default \"spdx\")\n      --sbom-dir string            Path to file where the SBOM will be written.\n      --tag-only                   Include tags but not digests in resolved image references. Useful when digests are not preserved when images are repopulated.\n  -t, --tags strings               Which tags to use for the produced image instead of the default 'latest' tag (may not work properly with --base-import-paths or --bare). (default [latest])\n      --tarball string             File to save images tarballs\n</code></pre>"},{"location":"reference/ko_run/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>  -v, --verbose   Enable debug logs\n</code></pre>"},{"location":"reference/ko_run/#see-also","title":"SEE ALSO","text":"<ul> <li>ko    - Rapidly iterate with Go, Containers, and Kubernetes.</li> </ul>"},{"location":"reference/ko_version/","title":"ko version","text":""},{"location":"reference/ko_version/#ko-version","title":"ko version","text":"<p>Print ko version.</p> <pre><code>ko version [flags]\n</code></pre>"},{"location":"reference/ko_version/#options","title":"Options","text":"<pre><code>  -h, --help   help for version\n</code></pre>"},{"location":"reference/ko_version/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>  -v, --verbose   Enable debug logs\n</code></pre>"},{"location":"reference/ko_version/#see-also","title":"SEE ALSO","text":"<ul> <li>ko    - Rapidly iterate with Go, Containers, and Kubernetes.</li> </ul>"}]}